<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE erlref SYSTEM "erlref.dtd">

<!-- %ExternalCopyright% -->

<erlref>
  <header>
    <copyright>
      <year>2022</year><year>2022</year>
      <holder>Maxim Fedorov, WhatsApp Inc.</holder>
    </copyright>
    <legalnotice>
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.

    </legalnotice>

    <title>hprof</title>
    <prepared>maximfca@gmail.com</prepared>
    <docno></docno>
    <date></date>
    <rev></rev>
  </header>
  <module since="OTP 26.0">hprof</module>
  <modulesummary>Process Heap Profiling Tool</modulesummary>
  <description>
    <p><c>hprof</c> provides convenience helpers for Erlang process heap
      profiling. Underlying mechanism is the Erlang trace BIFs.</p>

      <p></p>

      <note><p>When profiling is enabled, expect a slowdown in program execution.</p></note>
  </description>

  <section>
    <title>Ad-hoc profiling</title>
    <p>
      Basic profiling providing accumulated memory allocation data. You can choose
      to print per-process statistics, total statistics, or omit printing and
      extract machine-readable data that you can later sort/print:
    </p>

    <code type="none"><![CDATA[
      1> hprof:profile(lists, seq, [1, 16]).

      ****** Process <0.179.0>    -- 100.00 % of total allocations ***
      MODUL FUN/ARITY   CALLS  WORDS  PER CALL  [     %]
      lists seq_loop/3      5     32         6  [100.00]
      32            [ 100.0]
      ok
    ]]></code>

    <p>
      By default tracing is enabled for all functions of all modules. When
      functions are created in the interactive shell, parts of shell code
      are also traced. It is however possible to limit the trace to specific
      functions or modules:
    </p>

    <code type="none"><![CDATA[
      1> hprof:profile(fun() -> lists:seq(1, 16) end).

      ****** Process <0.224.0>    -- 100.00 % of total allocations ***
      MODULE   FUN/ARITY         CALLS  WORDS  PER CALL  [    %]
      erl_eval match_list/6          1      3         3  [ 3.19]
      erl_eval do_apply/7            1      3         3  [ 3.19]
      lists    reverse/1             1      4         4  [ 4.26]
      erl_eval add_bindings/2        1      5         5  [ 5.32]
      erl_eval expr_list/7           3      7         2  [ 7.45]
      erl_eval ret_expr/3            4     16         4  [17.02]
      erl_eval merge_bindings/4      3     24         8  [25.53]
      lists    seq_loop/3            5     32         6  [34.04]

      2> hprof:profile(fun() -> lists:seq(1, 16) end, #{pattern => [{lists, seq_loop, '_'}]}).
      ****** Process <0.247.0>    -- 100.00 % of total allocations ***
      MODUL FUN/ARITY   CALLS  WORDS  PER CALL  [     %]
      lists seq_loop/3      5     32         6  [100.00]
    ]]></code>

    <p>
      Ad-hoc profiling results may be printed in a few different ways. Following
      examples are using <c>test</c> module defined like this:
    </p>

    <code type="erl">
      -module(test).
      -export([test_spawn/0]).
      test_spawn() ->
          {Pid, MRef} = spawn_monitor(fun () -> lists:seq(1, 32) end),
          receive
              {'DOWN', MRef, process, Pid, normal} ->
                  done
          end.
    </code>

    <p>Default format prints per-process statistics.</p>
    <code type="none"><![CDATA[
        2> hprof:profile(test, test_spawn, []).

        ****** Process <0.176.0>    -- 23.66 % of total allocations ***
        MODULE FUN/ARITY        CALLS  WORDS  PER CALL  [    %]
        erlang spawn_monitor/1      1      2         2  [ 9.09]
        erlang spawn_opt/4          1      6         6  [27.27]
        test   test_spawn/0         1     14        14  [63.64]
                                          22            [100.0]

        ****** Process <0.177.0>    -- 76.34 % of total allocations ***
        MODULE FUN/ARITY   CALLS  WORDS  PER CALL  [    %]
        erlang apply/2         1      7         7  [ 9.86]
        lists  seq_loop/3      9     64         7  [90.14]
                                     71            [100.0]
    ]]></code>

    <p>This example prints the combined memory allocation of
        all processes, sorted by total allocated words in the descending order</p>
    <code type="none"><![CDATA[
        5> hprof:profile(test, test_spawn, [], #{report => {total, {words, descending}}}).

        MODULE FUN/ARITY        CALLS  WORDS  PER CALL  [    %]
        lists  seq_loop/3           9     64         7  [68.82]
        test   test_spawn/0         1     14        14  [15.05]
        erlang apply/2              1      7         7  [ 7.53]
        erlang spawn_opt/4          1      6         6  [ 6.45]
        erlang spawn_monitor/1      1      2         2  [ 2.15]
                                          93            [100.0]
    ]]></code>

    <p>You can also collect the profile for further inspection.</p>
    <code type="none"><![CDATA[
      6> {done, ProfileData} = hprof:profile(fun test:test_spawn/0, #{report => return}).
      <...>
      7> hprof:format(hprof:inspect(ProfileData, process, {percent, descending})).

      ****** Process <0.223.0>    -- 23.66 % of total allocations ***
      MODULE FUN/ARITY        CALLS  WORDS  PER CALL  [    %]
      test   test_spawn/0         1     14        14  [63.64]
      erlang spawn_opt/4          1      6         6  [27.27]
      erlang spawn_monitor/1      1      2         2  [ 9.09]
      22            [100.0]

      ****** Process <0.224.0>    -- 76.34 % of total allocations ***
      MODULE FUN/ARITY   CALLS  WORDS  PER CALL  [    %]
      lists  seq_loop/3      9     64         7  [90.14]
      erlang apply/2         1      7         7  [ 9.86]
      71            [100.0]
    ]]></code>

    <p>
      By default, basic profiling takes into account all processes spawned
      from the user-provided function (using <c>set_on_spawn</c> argument for
      trace/3 BIF). You can limit the trace to a single process:
    </p>

    <code type="none"><![CDATA[
      2> hprof:profile(test, test_spawn, [], #{set_on_spawn => false}).

      ****** Process <0.183.0>    -- 100.00 % of total allocations ***
      MODULE FUN/ARITY        CALLS  WORDS  PER CALL  [    %]
      erlang spawn_monitor/1      1      2         2  [ 9.09]
      erlang spawn_opt/4          1      6         6  [27.27]
      test   test_spawn/0         1     14        14  [63.64]
    ]]></code>

    <p>
      Erlang programs may perform memory-intensive operations in processes
      that are different from the original one. You can include multiple, new or
      even all processes in the trace.
    </p>

    <code type="none"><![CDATA[
      7> pg:start_link().
      {ok,<0.252.0>}
      8> hprof:profile(fun () -> pg:join(group, self()) end, #{rootset => [pg]}).
      ****** Process <0.252.0>    -- 52.86 % of total allocations ***
      MODULE     FUN/ARITY                 CALLS  WORDS  PER CALL  [    %]
      pg         leave_local_update_ets/5      1      2         2  [ 1.80]
      gen        reply/2                       1      3         3  [ 2.70]
      erlang     monitor/2                     1      3         3  [ 2.70]
      gen_server try_handle_call/4             1      3         3  [ 2.70]
      gen_server try_dispatch/4                1      3         3  [ 2.70]
      maps       iterator/1                    2      4         2  [ 3.60]
      maps       take/2                        1      6         6  [ 5.41]
      pg         join_local_update_ets/5       1      8         8  [ 7.21]
      pg         handle_info/2                 1      8         8  [ 7.21]
      pg         handle_call/3                 1      9         9  [ 8.11]
      gen_server loop/7                        2      9         4  [ 8.11]
      ets        lookup/2                      2     10         5  [ 9.01]
      pg         join_local/3                  1     11        11  [ 9.91]
      pg         notify_group/5                2     16         8  [14.41]
      erlang     setelement/3                  2     16         8  [14.41]
      111            [100.0]

      ****** Process <0.255.0>    -- 47.14 % of total allocations ***
      MODULE   FUN/ARITY         CALLS  WORDS  PER CALL  [    %]
      erl_eval match_list/6          1      3         3  [ 3.03]
      erlang   monitor/2             1      3         3  [ 3.03]
      lists    reverse/1             2      4         2  [ 4.04]
      pg       join/3                1      4         4  [ 4.04]
      erl_eval add_bindings/2        1      5         5  [ 5.05]
      erl_eval do_apply/7            2      6         3  [ 6.06]
      gen      call/4                1      8         8  [ 8.08]
      erl_eval expr_list/7           4     10         2  [10.10]
      gen      do_call/4             1     16        16  [16.16]
      erl_eval ret_expr/3            4     16         4  [16.16]
      erl_eval merge_bindings/4      3     24         8  [24.24]
      99            [100.0]
    ]]></code>

    <p>
      There is no default limit on the profiling time. It is possible to
      define such limit for ad-hoc profile. If function being profiled
      does not return in a specified amount of time, process is terminated
      with <c>kill</c> reason. Any unlinked children started by the
      user-supplied function are kept, it is developer's responsibility
      to ensure cleanup.
    </p>

    <code type="none">
      9> hprof:profile(timer, sleep, [100000], #{timeout => 1000}).
    </code>

    <p>By default, only one ad-hoc or server-aided profiling session is allowed
      at any point in time. It is possible to force multiple ad-hoc sessions
      concurrently, but it is developer responsibility to ensure non-overlapping
      trace patterns.
    </p>

    <code type="none">
      1> hprof:profile(fun() -> lists:seq(1, 32) end,
          #{registered => false, pattern => [{lists, '_', '_'}]}).
    </code>

  </section>

  <section>
    <title>Server-aided profiling</title>
    <p>
      Memory profiling can be done when your system is up and running. You
      can start the <c>hprof</c> server, add trace patterns and processes
      to trace while your system handles actual traffic. You can extract
      the data any time, inspect, and print. The example below traces
      activity of all processes supervised by kernel:
    </p>

    <code type="none"><![CDATA[
      1> hprof:start().
      {ok,<0.200.0>}
      2> hprof:enable_trace({all_children, kernel_sup}).
      34
      3> hprof:set_pattern('_', '_' , '_').
      16728
      4> Sample = hprof:collect().
      [{gen_server,try_dispatch,4,[{<0.154.0>,2,6}]},
      {erlang,iolist_to_iovec,1,[{<0.161.0>,1,8}]},
      <...>
      5 > hprof:format(hprof:inspect(Sample)).

      ****** Process <0.154.0>    -- 14.21 % of total allocations ***
      MODULE     FUN/ARITY       CALLS  WORDS  PER CALL  [    %]
      maps       iterator/1          2      4         2  [15.38]
      gen_server try_dispatch/4      2      6         3  [23.08]
      net_kernel handle_info/2       2     16         8  [61.54]
                                           26            [100.0]

      ****** Process <0.161.0>    -- 85.79 % of total allocations ***
      MODULE     FUN/ARITY            CALLS  WORDS  PER CALL  [    %]
      disk_log   handle/2                 2      2         1  [ 1.27]
      disk_log_1 maybe_start_timer/1      1      3         3  [ 1.91]
      disk_log_1 mf_write_cache/1         1      3         3  [ 1.91]
      <...>
    ]]></code>
  </section>

  <funcs>
    <func>
      <name name="start" arity="0" since="OTP 26.0"/>
      <fsummary>Start profiling server.</fsummary>
      <desc>
        <p> Starts the server, not supervised.
            Profiling server stores current trace patterns and
            ensures a single instance of heap profiler is running.</p>
      </desc>
    </func>
    <func>
      <name name="start_link" arity="0" since="OTP 26.0"/>
      <fsummary>Start profiling server.</fsummary>
      <desc>
          <p> Starts the server, supervised by the calling process.</p>
      </desc>
    </func>
    <func>
      <name name="stop" arity="0" since="OTP 26.0"/>
      <fsummary>Start profiling server.</fsummary>
      <desc>
        <p>Stops the <c>hprof</c>, disabling memory tracing that has
          been enabled by this server.</p>
      </desc>
    </func>

    <func>
      <name name="set_pattern" arity="3" since="OTP 26.0"/>
      <fsummary>Enables memory tracing for a specific trace pattern.</fsummary>
      <desc>
          <p>Turns tracing on for the supplied pattern.
          Requires running <c>hprof</c>. Patterns are additive, following
          the same rules as <seeerl marker="erts:erlang#trace_pattern/3">
          <c>erlang:trace_pattern/3</c></seeerl>.</p>
      </desc>
    </func>

    <func>
      <name name="clear_pattern" arity="3" since="OTP 26.0"/>
        <fsummary>Disables memory tracing for a specific trace pattern.</fsummary>
        <desc>
            Turns tracing off for the supplied pattern.
        </desc>
    </func>

    <func>
      <name name="get_trace_map" arity="0" since="OTP 26.0"/>
        <fsummary>Returns trace map.</fsummary>
        <desc>
            Returns a map of module names to functions with their arities.
        </desc>
    </func>

    <func>
      <name name="enable_trace" arity="1" since="OTP 26.0"/>
      <name name="enable_trace" arity="2" since="OTP 26.0"/>
        <fsummary>Enables call tracing for the specified processes</fsummary>
        <desc>
            Similar to <seeerl marker="erts:erlang#trace/3">
          <c>erlang:trace/3</c></seeerl>, but supports a few more options for
          tracing convenience.
        </desc>
    </func>
  </funcs>
</erlref>

